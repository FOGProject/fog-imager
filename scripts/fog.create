#!/bin/bash

### BEGIN VARIABLES
SCRIPT_DIR=$(cd -P `dirname ${BASH_SOURCE[0]}` && pwd)
shareDir="/images" # Remote share dir
jobName="tmpJob" #
destDir="${shareDir}/${jobName}"
### END VARIABLES

### BEGIN SOURCE VARIABLES
# TODO - Save this for the resizable partitioning
#if [ "$SOURCED_GPT_GUID" == "true" ]; then
#	. ${SCRIPT_DIR}/lib/gpt.guid
#fi
### END SOURCE VARIABLES`

### BEGIN FUNCTIONS
function initDest() {
	if [ -d $destDir ]; then
		echo -e "\nWARNING! Destination directory $destDir exists!"
		echo "Drive(s) will not be copied!"
		exit 1
	else
		mkdir -p $destDir
	fi
}

function getDiskList() {
	local rval=`lsblk -dpno KNAME,MAJ:MIN -x KNAME | awk -F'[ :]+' '{
	if ($2 == "3" || $2 == "8" || $2 == "9")
		print $1
	}'`

	echo "$rval"
}

# Gets partition table type
# $1: Disk to scan
# Outputs type of table
function getTableType() {
	local target=$1

	local sfdiskd=`sfdisk -d $target`
	local tableType=`echo $sfdiskd | awk /^label:\ /'{print $2}'`

	echo "$tableType"
}

# $1: Disk to save partitions from
# $2: Disk number
function savePartitions() {
	local target=$1
	local number=$2
	local partDataList=`sfdisk -d $target | grep start=`

	# Set IFS to newline for loop
	ORIG_IFS=$IFS
	IFS=$'\n'
	for partData in ${partDataList}; do
		local partName=`echo $partData | awk -F'[ :,=]+' '{print $1}'`
		local partID=`echo $partData | awk -F'[ :,=]+' '{print $7}'`
		
		echo "Processing partition \"$partName\""
		# If partition is extended, save EBR
		if [ "$partID" == "5" ] || [ "$partID" == "f" ]; then
			echo "Extended partition detected. This does nothing at this time."	
		else
			# Check for valid file systems
			local partFs=`blkid -po udev $partName \
				| awk -F'=' /ID_FS_TYPE=/'{print $2}'`
			local partFile="${destDir}/d${number}p${partName##*[a-z]}.img"

			mkfifo /tmp/pigz
			# This supports image sizes up to 10.2 TB
			pigz $PGIZ_COMP < /tmp/pigz | split -a 4 -d -b 1024m - ${partFile}. &

			# Use partclone or save swap UUID
			if [ "$partFs" == "ntfs" ]; then
				partclone.ntfs -c -s $partName -O /tmp/pigz -N -f 1 2>> /tmp/partclone.log
			elif [ "$partFs" == "vfat" ]; then
				partclone.fat -c -s $partName -O /tmp/pigz -N -f 1 2>> /tmp/partclone.log
			elif [ "$partFs" == "hfsplus" ]; then
				partclone.hfsp -c -s $partName -O /tmp/pigz -N -f 1 2>> /tmp/partclone.log
			elif [ "$partFs" == "swap" ]; then
				local swapFile="${destDir}/d${number}.swap"
				blkid -s UUID ${partName} | cut -d\" -f2 > $swapFile
			elif [[ "$partFs" =~ ^ext[234] ]]; then
				partclone.extfs -c -s $partName -O /tmp/pigz -N -f 1 2>> /tmp/partclone.log
			else
				echo "FATAL: Unsupported partition "$partFs" detected!"
				exit 2
			fi
			mv ${partFile}{.000,} 2>/dev/null
			rm /tmp/pigz
		fi
	done
	IFS=$ORIG_IFS
}

# $1: Disk to process
# $2: Disk number
function processMbrDisk() {
	local target=$1
	local number=$2
	local destFile="${destDir}/d${number}.mbr.bin"

	# Save MBR manually
	dd if=$target of=$destFile bs=512 count=1
	# TODO - Save slack space between partition table and first partition?
}

# $1: Disk to process
# $2: Disk number
function processGptDisk() {
	local target=$1
	local number=$2
	local destFile="${destDir}/d${number}.gpt.bin"

	# TODO - Check partition table for errors
	# Save partition table
	sgdisk -b $destFile $target
	# TODO - Save slack space between partition table and first partition?
}
### END FUNCTIONS

initDest

# Get all disks
diskList=`getDiskList`

diskCount=1
for disk in ${diskList}; do
	echo -e "Processing $disk"
	# Get partition table type
	tableType=`getTableType $disk`

	if [ "$tableType" == "dos" ]; then
		processMbrDisk $disk $diskCount
	elif [ "$tableType" == "gpt" ]; then
		processGptDisk $disk $diskCount
	fi
	savePartitions $disk $diskCount

done

echo -e "Image save complete.\n"

#!/bin/bash

### BEGIN VARIABLES
SCRIPT_DIR=$(cd -P `dirname ${BASH_SOURCE[0]}` && pwd)
shareDir="/images" # Remote share dir
jobName="tmpJob"
srcDir="${shareDir}/${jobName}"
### END VARIABLES

### BEGIN SOURCE VARIABLES
# TODO - Save this for the resizable partitioning
#if [ "$SOURCED_GPT_GUID" == "true" ]; then
#   . ${SCRIPT_DIR}/lib/gpt.guid
#fi
### END SOURCE VARIABLES

### BEGIN FUNCTIONS
function initSrc() {
	if [ ! -d "$srcDir" ]; then
		echo -e "\nFATAL! Source directory \"${srcDir}\" does not exist!"
		echo "Imaging process cannot continue!"
		exit 1
	fi
	# TODO - Turn into function to check any disks.
	if [ ! -f "${srcDir}/d1.mbr" ] && [ ! -f "${scrDir}/d1.gpt" ]; then
		echo -e "\nFATAL! No partition table detected in source directory!"
		echo "Imaging process cannot continue!"
		exit 2
	fi
	if [ ! -f "${srcDir}/d1p1.img" ]; then
		echo -e "\nFATAL! No initial image file detected in source directory!"
		echo "Imaging process cannot continue!"
		exit 3
	fi
}

function getDiskList() {
	local rval=`lsblk -dpno KNAME,MAJ:MIN -x KNAME | awk -F'[ :]+' '{
		if ($2 == "3" || $2 == "8" || $2 == "9")
			print $1
		}'`

	echo "$rval"
}

# $1: Target disk
function probeParts() {
	local target=$1

	udevadm settle
	blockdev --rereadpt $target > /dev/null 2>&1
	if [ "$?" != "0" ]; then
		echo "FATAL! Unable to read back partitions!"
		exit 4
	fi
}

# $1: Partition target to deploy to
# $2: Disk number
function deployPartTable() {
	local diskName=$1
	local diskNum=$2

	# Wipe partition table
	# TODO - Consider wiping out slack space before first partition
	dd if=/dev/zero of=$disk bs=512 count=1 2>/dev/null

	if [ -f "${srcDir}/d${diskNum}.mbr" ]; then
		local tableFile=${srcDir}/d${diskNum}.mbr
	elif [ -f "${srcDir}/d${diskNum}.gpt" ]; then
		local tableFile=${srcDir}/d${diskNum}.gpt
	fi
	# Restore partition table
	sfdisk $diskName < $tableFile
	# TODO - Handle post-MBR slack space?
	probeParts $diskName
}

# $1: Partition image base file name
# $2: Partition target to deploy to
function deployPartition() {
	local partImg=$1
	local partName=$2

	mkfifo /tmp/pigz
	cat ${partImg} > /tmp/pigz &

	pigz -d -c < /tmp/pigz | \
		partclone.restore --ignore_crc -O $partName -N -f 1 \
		2>>/tmp/partclone.log
	
	rm /tmp/pigz
}

# $1: Target disk
# $2: Disk number
function processPartitions() {
	local target=$1
	local number=$2
	local partDataList=`sfdisk -d $target | awk /start=/'{print $1}'`
	
	for partName in ${partDataList}; do
		echo "Deploying $partName"
		deployPartition ${srcDir}/d${number}p${partName##*[a-z]}.img ${partName}
	done
}
### END FUNCTIONS

initSrc

diskList=`getDiskList`

diskCount=1
for disk in ${diskList}; do
	echo "Processing disk $disk"
	deployPartTable $disk $diskCount
	processPartitions $disk $diskCount
done

echo -e "Image deploy complete.\n"

#!/bin/bash

### BEGIN VARIABLES
SCRIPT_DIR=$(cd -P `dirname ${BASH_SOURCE[0]}` && pwd)
shareDir="/images" # Remote share dir
jobName="tmpJob"
srcDir="${shareDir}/${jobName}"
### END VARIABLES

### BEGIN SOURCE VARIABLES
# TODO - Save this for the resizable partitioning
#if [ "$SOURCED_GPT_GUID" == "true" ]; then
#   . ${SCRIPT_DIR}/lib/gpt.guid
#fi
### END SOURCE VARIABLES

### BEGIN FUNCTIONS
function initSrc() {
	if [ ! -d "$srcDir" ]; then
		echo -e "\nFATAL! Source directory \"${srcDir}\" does not exist!"
		echo "Imaging process cannot continue!"
		exit 1
	fi
	# TODO - Turn into function to check any disks.
	if [ ! -f "${srcDir}/d1.mbr" ] && [ ! -f "${scrDir}/d1.gpt" ]; then
		echo -e "\nFATAL! No partition table detected in source directory!"
		echo "Imaging process cannot continue!"
		exit 2
	fi
	if [ ! -f "${srcDir}/d1p1.img" ]; then
		echo -e "\nFATAL! No initial image file detected in source directory!"
		echo "Imaging process cannot continue!"
		exit 3
	fi
}

function getDiskList() {
	local rval=`lsblk -dpno KNAME,MAJ:MIN -x KNAME | awk -F'[ :]+' '{
		if ($2 == "3" || $2 == "8" || $2 == "9")
			print $1
		}'`

	echo "$rval"
}

# $1: Target disk
function probeParts() {
	local target=$1

	udevadm settle
	blockdev --rereadpt $target > /dev/null 2>&1
	if [ "$?" != "0" ]; then
		echo "FATAL! Unable to read back partitions!"
		exit 4
	fi
}

# $1: Partition target to deploy to
# $2: Disk number
function deployPartTable() {
	local diskName=$1
	local diskNum=$2
	local sfdiskFile=${srcDir}/d${diskNum}.partitions

	# Wipe partition table and more than average slack space
	dd if=/dev/zero of=$disk bs=512 count=4096 2>/dev/null

	if [ -f "${srcDir}/d${diskNum}.mbr" ]; then
		local tableFile=${srcDir}/d${diskNum}.mbr
	elif [ -f "${srcDir}/d${diskNum}.gpt" ]; then
		local tableFile=${srcDir}/d${diskNum}.gpt
	else
		echo "FATAL! Partition table missing!"
	fi

	# Restore raw partition table
	dd if=$tableFile of=$diskName bs=512 count=${firstSector}

	probeParts $diskName
}

# $1: Partition image base file name
# $2: Partition target to deploy to
function deployPartition() {
	local partImg=$1
	local partName=$2

	mkfifo /tmp/pigz
	cat ${partImg} > /tmp/pigz &

	pigz -d -c < /tmp/pigz | \
		partclone.restore --ignore_crc -O $partName -N -f 1
	
	rm /tmp/pigz
}

# $1: Target disk
# $2: Disk number
function processPartitions() {
	local target=$1
	local number=$2
	local partDataList=`sfdisk -d $target | grep start=`
	
	# Set IFS to newline for loop
	ORIG_IFS=$IFS
	IFS=$'\n'
	for partData in ${partDataList}; do
		local partName=`echo $partData | awk -F'[ :,=]+' '{print $1}'`
		local partID=`echo $partData | awk -F'[ :,=]+' '{print $7}'`
		
		if [ "$partID" == "5" ]; then
			echo "Extended partition detected. This does nothing."
		elif [ "$partID" == "82" ]; then
			echo "Setting up swap partition with original UUID."
			local swapUUID=`head ${srcDir}/d${number}.swap`
			mkswap -U $swapUUID $partName
		else
			echo "Deploying $partName"
			deployPartition ${srcDir}/d${number}p${partName##*[a-z]}.img ${partName}
		fi
	done
	IFS=$ORIG_IFS
}
### END FUNCTIONS

initSrc

diskList=`getDiskList`

diskCount=1
for disk in ${diskList}; do
	echo "Processing disk $disk"
	deployPartTable $disk $diskCount
	processPartitions $disk $diskCount
done

echo -e "Image deploy complete.\n"
